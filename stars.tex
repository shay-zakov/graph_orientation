 \section{Algorithms for stars}\label{s.1}
 A $n$-star $S$ is a tree with one internal node $c$ and $n$ leaves.
 
% Say that u dominates v if both $w(c, u) \geq w(c, v)$ and $w(u, c)\geq w(v, c)$. When visualizing the leaves as a set of 2D points, the point corresponding to u dominates all points which are to the left and below it.
% 
% First, we can argue that we can exclude from consideration all vertices which are dominated by other vertices. For example, if v is dominated by u, then whatever the direction of {c, u} in the star orientation we chose the same direction for {c, v} and don't increase the overall score. This leaves us with a subset of dominating vertices (if two or more vertices have exactly the same in and out weights and are not dominated by any other vertex, we take one of them as a representative in the dominating set). When sorting this set according to non-decreasing out-weights, we get a sequence of strictly increasing out-weights and strictly decreasing in-weights (because no vertex in the set dominates another vertex in it). Let's denote this sequence of vertices by $u_1, u_2, ..., u_r$, and 
% add for convenience $u_0$ with $-\infty /+\infty$ out/in weights, and $u_{r+1}$ with 
% $\infty /-\infty$ out/in weights. 
% 
% Now, let's assume an optimal star orientation that includes $(c, u_j)$ for some $u_j$ in the dominating set. Clearly, we can orient all edges $\{c, u_i\}$ for $i < j$ as $(c, u_i)$ (since $w(c, u_i) < w(c, u_j)$). Similarly, if the orientation includes $(u_j, c)$ we can orient every $\{c, u_i\}$ with $i > j$ as $(u_i, c)$. Therefore, there exists some optimal orientation and a corresponding index $0 < j \leq r+1$ such for all $i < j$ we have the edges $(c, u_i)$, and for all $i \geq j$ we have $(u_i, c)$. The score of this orientation is $\max(w(c, u_{j-1}), w(u_j, c))$. So the algorithm can do a binary search over the sequence of dominating vertices and find an optimal star orientation.
% 
% For the first instance, finding and sorting the dominating set takes $O(n \log n)$ time, and then finding the optimal j takes an additional $O(\log n)$ time. When updating the instance by changing one edge weight, we just need to update the dominating set similarly as done for the linear graph $H_m$ algorithm in $O(log n)$ time, and again find the optimal $j$ in $O(\log n)$ time.

 \subsection{An algorithm for cost function $H_m$}
 \begin{algorithm}\label{a.starm}
 	\KwIn{a bi-weighted $n$-star $S$}
 	\KwOut{an optimal orientation of $S$ under $H_m$}
 	
Orient each edge $\{u,c\}$ inwards to \textit{c} if $w(u,c)<w(c,u)$,
and outward from $c$ otherwise\; \label{i0}
 	 
denote by $\tildeb{S}$ the resulting directed graph, by $BestCost$ its cost, 
by $E_{in}=\{(u_1,c),\ldots, (u_{\ell},c)\}$ the list of its inward edges, 
and by $E_{out}=\{(c,v_1),\ldots, (c,v_r)\}$ the list of its outward edges\;
\label{i00} reorder each of $E_{in}$ and $E_{out}$ so that
the weights of its edges are in non-increasing order\;

set $\tildeb{S'}$ to $\tildeb{S}$\;

\For {$k= 1$ to $\ell$}
  {update $\tildeb{S'}$ by flipping the direction of edge $(u_k,c)$, and update $BestCost$ if necessary;}
   \label{i1} 
set $\tildeb{S'}$ to $\tildeb{S}$\;
\For {$k= 1$ to $r$}
   {update $\tildeb{S'}$ by flipping the direction of edge $(c,v_k)$, and update $BestCost$ if necessary;}
  \label{i2}
 	\Return an orientation whose cost is $BestCost$\;
 	\caption{Algorithm BestOrientStar$_m (S)$}
 	\label{algo:os-s}
 \end{algorithm}

\bigskip

To establish the correctness of the algorithm we first prove its key observation:  
if initially  each edge is oriented
so that it points in its lighter direction then an optimal orientation can be
found by only flipping edges that were initially pointing inwards or only
flipping edges that were initially pointing outwards. 
\begin{lemma}\label{l.best}
	There is no optimal orientation in which both the largest inward edge weight is less than $w(u_1,c)$ 
	and the largest outward edge weight is less than $w(c,v_1)$.
\end{lemma}

\noindent \textbf{Proof:}
Note that the cost of the initial orientation is $h_m(\tildeb{S})=w(u_1,c)+w(c,v_1)$.
Suppose, by contradiction, that there is an optimal orientation $\tildeb{S}^*$ 
with largest inward weight $w(x,c)< w(u_1,c)$,
and largest outward weight $w(c,y)<w(c,v_1)$.
Then $h_m(\tildeb{S}^*)=w(x,c)+w(c,y)$.
The initial orientation implies that $w(c,u_1) > w(u_1,c)$, and $w(v_1,c) \geq w(c,v_1)$.
Since $\{u_1,c\}$ is an outward edge in $\tildeb{S^*}$ and $\{v_1,c\}$ an inward edge,
$h_m(\tildeb{S}^*)\geq  
w(v_1,c)+w(c,u_1) >  w(u_1,c)+w(c,v_1) =h_m(\tildeb{S})$, a contradiction.
\qed

\begin{theorem}\label{t.star}
%	[Correctness of the algorithm]
Algorithm \emph{BestOrientStar}$_m$ finds an optimal orientation in  $O(n \log n)$ steps.
\end{theorem}  

\noindent \textbf{Proof:}

 Let $\tildeb{S}^*$ be an optimal orientation of the input $n$-star $S$.
 
 If the edges in $\tildeb{S}^*$ are all oriented outwards, or all oriented 
 inwards, then the algorithm will find an optimal orientation
 at the completion of the loop of statement \ref{i1}, or
of statement \ref{i2}, respectively.
 
 Otherwise at least one of the edges $(u_1,c)$ and $(c,v_1)$ takes part 
 in $\tildeb{S}^*$, according to Lemma \ref{l.best}. If both participate then an optimal orientation is found in step \ref{i0}.
 If not, we consider and prove the case that $(c,v_1)$ participates. 
 
 Note first of all that if there is an inward edge in $\tildeb{S}^*$ that is oriented as
 an outward edge in $\tildeb{S}$ then flipping that edge cannot
 increase the cost of the orientation, because its outward weight does not exceed $w(c,v_1)$.
 We can assume, therefore, that all edges in $E_{out}$ participate in $\tildeb{S}^*$. 
 Let $(u_j,c)$ be the 
 edge from $E_{in}$ with least index that participates in $\tildeb{S}^*$, 
  $w(u_j,c)<w(u_1,c)$, i.e. all edges $\{u_i,c\}, 1\leq i<j$, are outward edges in $\tildeb{S}^*$. 
 The cost of $\tildeb{S}^*$ is therefore 
 $$h_m(\tildeb{S}^*)=w(u_j,c)+\max \{w(c,v_1),\max \{w(c,u_i):1\leq i<j)\}\}.$$
To complete the proof we observe that $h_m(\tildeb{S}^*)$ is precisely the value of the orientation
obtained by the algorithm after flipping the edge  $\{u_{j-1},c\}$
 in iteration $k=j-1$ of the loop of step \ref{i1}.

The running time  analysis is straightforward: the reordering of step \ref{i00} takes
$O(n \log n)$, and each update of $BestCost$ in loops \ref{i1} and \ref{i2} takes 
constant time if  auxiliary variables are maintained for the values of 
$\max \{w(c,u_i):1\leq i<j)\}$ and $\max \{w(v_i,c):1\leq i<j)\}$.
 \qed
 
  \subsection{An algorithm for cost function $H_s$}
  An algorithm for cost function $H_s$ is obtained by slightly modifying Algorithm BestOrientStar$_m$ using the following observation.
  
  \begin{lemma}
  	Only the weights of positive weight edges can contribute to the value of $h_s(\tildeb{S})$ for an oriented star $\tildeb{S}$.
  \end{lemma} 
\begin{proof}
	The length of a path in an oriented star is no more than 2. 
	An edge with non-positive weight is therefore either the first or 
	the last edge on any path, and does not contribute to its cost. 
\end{proof}

Here is the outline of the resulting algorithm for cost function $H_s$:
 \begin{algorithm}\label{a.stars}
	\KwIn{a bi-weighted $n$-star $S$}
	\KwOut{an optimal orientation of $S$ under $H_s$}	
	remove from $S$ every edge with a direction of non-positive weight, and denote the resulting star $S'$
	\label{s.rem} \;
	set $\tildeb{S'}$ to $\mbox{BestOrientStar}_m (S')$\;
	direct each edge removed in statement \ref{s.rem} in a direction of non-positive weight,
	and add it to $\tildeb{S'}$;
	denote the resulting directed star $\tildeb{S}$\;
	\Return $\tildeb{S}$\;
	\caption{Algorithm BestOrientStar$_s (S)$}
	\label{algo:oc-s}
\end{algorithm}
