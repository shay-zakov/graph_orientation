\subsection{Running time under cost function $H_m$}
We show here that 
Algorithm BestCostPath$_m$ can be made to run in time $O(n \log n)$.
As in the case of cost function $H_s$, the key is the analysis and careful implementation
of statements \ref{st.1} and \ref{st.2} of the algorithm.

As for computing $h_m(\vec{L}_{i, j})$, combining equations (\ref{eq.W}) and (\ref{eq.hm})
gives
\begin{equation}\label{eq.hmij}
h_m(\vec{L}_{i, j})=W_{j}-W_{i}= \sum_{t=i}^{j-1}w(t,t+1),
\end{equation}
where $W_{j}= \sum_{t=0}^{j-1}w(t,t+1)$, $W_0=0$.
A similar equality holds for $h_m(\cev{L}_{i, j})$.
Consequently, finding the minimum values in statements \ref{st.1} and \ref{st.2} takes on a form 
that is very different from the one obtained for $H_s$. Focusing on statement \ref{st.1}, 
equation (\ref{eq.hmij}) shows that for $1\leq j \leq n$

\begin{equation}
\begin{array}{ll@{}l}
H^{\succ}(j)
%&=\min_{0\leq i <j}\max &\{ H^{\prec}(i), h_m(\vec{L}_{i, j})\}\nonumber \\
&=\min_{0\leq i <j} \max &\{ H^{\prec}(i), W_{j}-W_{i} \}\nonumber.
\end{array}
\end{equation}
Let us split the points of the interval ${0\leq i <j}$ into those that satisfy 
$H^{\prec}(i)+W_{i}\geq W_{ j}$ and the remainder. Since $H^{\prec}(0)=-\infty$, 
the point $i=0$ belongs to the latter. In particular, $H^{\succ}(1)=W_1$, and for $j\geq 2$
$H^{\succ}(j)=\min \{M_1(j),W_{j}-M_2(j)\}$,  with 
\begin{align}
M_1(j)&=\min_{1\leq i <j } \{H^{\prec}(i) \mid 
       H^{\prec}(i)+W_{i}\geq W_{ j}
       \}, \label{e.min-m}\\
M_2(j)& =\min_{0\leq i <j} \{W_{ j}-W_{ i} \mid  
       H^{\prec}(i)+W_{i}<  W_{j}
       \}. \label{e.max-m}
\end{align}
We turn now to describing the data structures that enable the efficient computation of the minima in equation (\ref{e.min-m});  equation (\ref{e.max-m}) can be handled similarly. 
Rephrased slightly more abstractly we need to solve the following problem.

\begin{problem}[\emph{Minima of sequence prefixes under key-bounds}]\label{p.msp}\ 

\noindent \emph{\bf Given:} A sequence $KV$ of $n$ pairs of the form $(key,value)$,
	and a sequence of lower bounds $W_j,\  1\leq j \leq n$, 

\noindent \emph{\bf Compute:} 
\begin{equation}
min_j(W_j)=\min \{value \mid (key,value)\in Pre_j \mbox{ \emph{and} } key \geq W_j\},  \mbox{ for }1\leq j \leq n, \label{e.min-m-v}
\end{equation}
where $Pre_j$ is the prefix of length $j$ of $KV$.
\end{problem}

To solve this problem efficiently we will maintain a set, whose members are 
pairs  $s_i=(key_{i}, value_{i})$, sorted by $key_i$.  
Denote by $S_j$ the sorted set formed after $j$ pairs
from $KV$ have been processed.
For convenience we add a first pair $(key_{0},\mu_{0})=(-\infty,-\infty)$
and a last pair
$(key_{\ell_j+1},value_{\ell_j+1})=(\infty,\infty)$, with $\ell_j=|S_j|-2$.
All pairs in $S_j$, except for the first and last, are also present in $Pre_j$ but some of the 
latter's pairs may be absent from $S_j$. 

The operations on $S_j$ are:
\begin{itemize}
	\item  Initialization: Set $S_0$ to $<(-\infty,-\infty), (\infty,\infty)>$.
	\item  Computing $min_j(W_j)$:\\
	find the smallest $key_{k}$ in $S_{j}$ such that 
	$W_j\leq key_{k}$;\\  \textbf{return} $value_{k}$.\\
	\item Updating $S_{j-1}$ to $S_j$ using the $j$-th pair $s=(key, value)$ from $KV$:
	\begin{enumerate}
		\item let $key_{m}$ be the smallest key in $S_{j-1}$ such that 
		$key < key_{m}$;
		\item {\bf if} $value\geq value_{m}$ \textbf{then} $S_j $ is the same as $S_{j-1}$;\\
		\{\emph{comment:  s=$(key,value)$ } is discarded\} ; \label{i.discard}
		\item \textbf{else} \label{i.else}
		  \begin{enumerate}
		  	\item set $k$ to $m-1$;\\  \textbf{while} $value_k \geq value $ \textbf{do} \\
		  		delete $s_k$ from $S_{j-1}$; set $k$ to  $k-1$;\label{i.while}
		  	\item  create $S_j$ by inserting $ s$ into $S_{j-1}$ between $s_k$ and $s_m$;
		  	\label{i.insert}
		  \end{enumerate} 
	\end{enumerate}
\end{itemize}
\begin{figure}[h]
	\centering
	\begin{minipage}{0.45\textwidth}
		\centering  
		\includegraphics[width=0.9\textwidth]{KV_2.eps}
		\caption{Computing $min_j(W_j)$.}\label{fig:min_fig}
	\end{minipage}\hfill
	\begin{minipage}{0.45\textwidth}
		\centering 
		\includegraphics[width=0.9\textwidth]{KV_update_2.eps}
		\caption{Updating $S_j$}\label{fig:update_fig}
	\end{minipage}
\end{figure}

Figure  \ref{fig:min_fig} illustrates the computation of $min_j(W_j)$: the step function represents 
$S_j$, the scattered points are $(key, value)$ pairs that were discarded, and the points to the right
of the broken vertical line are the ones whose minimum value is to be found.

Figure \ref{fig:update_fig} illustrates the updating of $S_j$: the star point is a new pair that is added
to $S_j$, and $S_j$ is updated by discarding the points on the step function that are above the horizontal line to the left  of the star point.

\begin{theorem}\label{p.kmu} The updating procedure preserves the following invariants of $S_j$.
  \begin{enumerate}
  	\item If $0\leq i_1< i_2 \leq \ell_j+1$ then $key_{i_1}< key_{i_2}$ and 
  	$value_{i_1} < value_{i_2}$.
  	\item Suppose some $s'=(key',value') \in Pre_j$ does not appear in $S_j$, and
  	$key_{i-1} < key' \leq key_i$. Then $value'\geq value_i$.
   \end{enumerate}
   Taken together the two invariants imply the correctness of the $\min_j$ computation: if $key_{i-1}<W\leq key_{i}$ for some $1\leq i \leq \ell_j+1$. then 
  	$\min_j(W)=value_{i}$.
\end{theorem}
\begin{proof}
By induction on $j$. When $j=0$ both invariants are clearly true.

For general $j$, if $s=(key,value)$ was discarded in statement \ref{i.discard}, then the first invariant holds because it did for $S_{j-1}$, and the second invariant is correctly updated
by statement \ref{i.discard}. 

If $s$ is not discarded, $S_j$ is updated according to statement \ref{i.else}. In this case $S_{j-1}$ and $S_j$ differ only in that 
the pairs $s_{k+1},\ldots s_{m-1}$ were deleted from $S_{j-1}$ and $s=(key,value)$ was
inserted between $s_k$ and $s_m$, with $k$ and $m$ as in
update statement \ref{i.insert}. Since $key_k<key <key_m$ and 
$value_k < value <value_m$ the first invariant is maintained.
Moreover, all pairs $(key',value')$
deleted in statement \ref{i.while}
satisfy $key_k<key'\leq key$, $value'\geq value$, so that the second invariant is correctly
updated.
\end{proof}
\begin{theorem}\label{t.linear-m}
	When the cost function used in Algorithm \emph{BestCostPath}$_x$ is $H_m$ its running time is $O(n\log n)$.
\end{theorem}
\begin{proof}
One possible implementation of the sorted set data structure uses red-black trees, \cite{guibas}.
The operations on the data structure used in our solution of Problem \ref{p.msp} -  insert, delete, and search - each take $O(\log n)$ time, resulting 
in an overall running time of $O(n \log n)$.
\end{proof}


